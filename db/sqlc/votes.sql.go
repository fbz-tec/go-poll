// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: votes.sql

package db

import (
	"context"
)

const createVote = `-- name: CreateVote :one
insert into votes (
    option_id,voter
) values (
    $1,$2
) returning vote_id, option_id, voter
`

type CreateVoteParams struct {
	OptionID int64  `json:"option_id"`
	Voter    string `json:"voter"`
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) (Vote, error) {
	row := q.db.QueryRow(ctx, createVote, arg.OptionID, arg.Voter)
	var i Vote
	err := row.Scan(&i.VoteID, &i.OptionID, &i.Voter)
	return i, err
}

const getTotalVotes = `-- name: GetTotalVotes :many
select o.option_value, count(v.vote_id) as vote_count
from options o
left join votes v on o.option_id = v.option_id
where o.poll_id = $1
group by o.option_id
`

type GetTotalVotesRow struct {
	OptionValue string `json:"option_value"`
	VoteCount   int64  `json:"vote_count"`
}

func (q *Queries) GetTotalVotes(ctx context.Context, pollID int64) ([]GetTotalVotesRow, error) {
	rows, err := q.db.Query(ctx, getTotalVotes, pollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTotalVotesRow{}
	for rows.Next() {
		var i GetTotalVotesRow
		if err := rows.Scan(&i.OptionValue, &i.VoteCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotesByPoll = `-- name: GetVotesByPoll :many
select vote_id, v.option_id, voter, option_value, poll_id 
from votes v 
inner join options o on v.option_id = o.option_id 
where o.poll_id = $1
limit $2
offset $3
`

type GetVotesByPollParams struct {
	PollID int64 `json:"poll_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetVotesByPollRow struct {
	VoteID      int64  `json:"vote_id"`
	OptionID    int64  `json:"option_id"`
	Voter       string `json:"voter"`
	OptionValue string `json:"option_value"`
	PollID      int64  `json:"poll_id"`
}

func (q *Queries) GetVotesByPoll(ctx context.Context, arg GetVotesByPollParams) ([]GetVotesByPollRow, error) {
	rows, err := q.db.Query(ctx, getVotesByPoll, arg.PollID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVotesByPollRow{}
	for rows.Next() {
		var i GetVotesByPollRow
		if err := rows.Scan(
			&i.VoteID,
			&i.OptionID,
			&i.Voter,
			&i.OptionValue,
			&i.PollID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVotesByUser = `-- name: GetVotesByUser :many
select vote_id, option_id, voter from votes
where voter ilike $1
limit $2
offset $3
`

type GetVotesByUserParams struct {
	Voter  string `json:"voter"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetVotesByUser(ctx context.Context, arg GetVotesByUserParams) ([]Vote, error) {
	rows, err := q.db.Query(ctx, getVotesByUser, arg.Voter, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vote{}
	for rows.Next() {
		var i Vote
		if err := rows.Scan(&i.VoteID, &i.OptionID, &i.Voter); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
